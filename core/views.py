"""
views.py — Cozy Triage view layer.
"""

from __future__ import annotations

import logging
from datetime import datetime, timezone

from django.contrib.auth import login
from django.contrib.auth.decorators import login_required
from django.shortcuts import redirect, render
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from core.forms import SignupForm
from core.services import graphrag_service
from core.dtos import UserNode, TaskStatus, TaskNode, ProjectNode, AreaNode

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# Auth views
# ---------------------------------------------------------------------------

def signup(request):
    """
    Create a Django user + matching Memgraph User node.
    On success, log the user in and redirect to dashboard.
    """
    if request.user.is_authenticated:
        return redirect("dashboard")

    if request.method == "POST":
        form = SignupForm(request.POST)
        if form.is_valid():
            django_user = form.save()
            # Sync to Memgraph — use Django's pk as the graph node id
            node = UserNode(
                id=str(django_user.pk),
                email=django_user.email,
                created_at=datetime.now(timezone.utc),
            )
            try:
                graphrag_service.create_user(node)
            except Exception:
                logger.exception(
                    "Memgraph User node creation failed for pk=%s", django_user.pk
                )
                # Don't block login — node sync can be retried; user exists in Django
            login(request, django_user)
            return redirect("dashboard")
    else:
        form = SignupForm()

    return render(request, "core/signup.html", {"form": form})


# ---------------------------------------------------------------------------
# Dashboard
# ---------------------------------------------------------------------------

@login_required
def dashboard(request):
    """
    Home view — shows top Next Actions and a quick-add input.
    """
    user_id = str(request.user.pk)
    next_tasks = []
    inbox_count = 0

    try:
        next_tasks = graphrag_service.list_tasks(user_id, status=TaskStatus.NEXT)[:5]
        inbox_tasks = graphrag_service.list_tasks(user_id, status=TaskStatus.INBOX)
        inbox_count = len(inbox_tasks)
    except Exception:
        logger.exception("Failed to load dashboard tasks for user %s", user_id)

    return render(request, "core/dashboard.html", {
        "next_tasks": next_tasks,
        "inbox_count": inbox_count,
    })


# ---------------------------------------------------------------------------
# Triage Pipeline
# ---------------------------------------------------------------------------

@login_required
def inbox(request):
    """
    Brain dump input form. On POST, runs the brain dump through the triage pipeline.
    """
    user_id = str(request.user.pk)
    
    if request.method == "POST":
        brain_dump = request.POST.get("brain_dump", "").strip()
        if not brain_dump:
            return render(request, "core/inbox.html", {
                "error": "Please enter what's on your mind.",
            })
            
        from core.services import triage_service
        result = triage_service.run_triage(user_id, brain_dump)
        
        if result.get("error"):
            # If the LLM call or graph call completely failed
            return render(request, "core/inbox.html", {
                "error": result["error"],
                "brain_dump_content": brain_dump,
            })
            
        session_id = result["session_id"]
        return redirect("triage_review", session_id=session_id)
        
    return render(request, "core/inbox.html")


@login_required
def triage_review(request, session_id):
    """
    Review suggestions generated by the triage pipeline.
    """
    user_id = str(request.user.pk)
    
    # Check if session exists and is owned by user
    session = graphrag_service.get_triage_session(user_id, session_id)
    if not session:
        return redirect("inbox")
        
    if request.method == "POST":
        from core.services import triage_service
        import json
        try:
            # Expected payload: '[{"id": "sug_uuid", "action": "accept", "edited_data": {...}}]'
            decisions = json.loads(request.POST.get("decisions", "[]"))
            triage_service.apply_suggestions(user_id, session_id, decisions)
            return redirect("tasks")
        except Exception as e:
            logger.exception(f"Failed to apply suggestions for session {session_id}")
            # Fall through to GET below and show error
            pass
            
    # GET: fetch suggestions
    suggestions = graphrag_service.get_suggestions_for_session(user_id, session_id)
    
    # Filter out already accepted/rejected suggestions
    pending_suggestions = [s for s in suggestions if s.accepted_bool is None]
    logger.debug(f"Session {session_id}: Total suggestions {len(suggestions)}, Pending {len(pending_suggestions)}")
    
    # If no pending suggestions left, this session is done
    if suggestions and not pending_suggestions:
        logger.info(f"Session {session_id} has no pending suggestions. Redirecting to tasks.")
        return redirect("tasks")
       
    # Parse payload back into Python dicts for the template
    import json
    parsed_suggestions = []
    for s in pending_suggestions:
        try:
            payload = json.loads(s.payload_json)
            parsed_suggestions.append({
                "id": s.id,
                **payload
            })
        except:
            pass
            
    return render(request, "core/triage_review.html", {
        "session": session,
        "suggestions": parsed_suggestions,
    })


# ---------------------------------------------------------------------------
# Tasks
# ---------------------------------------------------------------------------

@login_required
def tasks(request):
    """
    Stub for Phase 5 tasks view.
    """
    return render(request, "core/base.html", {"message": "Tasks placeholder (Phase 5)"})


# ── JSON API (for New Frontend) ──────────────────────────────────────────────

def api_auth_check(request):
    if not request.user.is_authenticated:
        return JsonResponse({"error": "Authentication required"}, status=401)
    return None

@csrf_exempt
def api_inbox(request):
    """
    JSON endpoint for brain dump submission.
    """
    auth_error = api_auth_check(request)
    if auth_error: return auth_error

    if request.method != "POST":
        return JsonResponse({"error": "POST required"}, status=405)
        
    import json
    try:
        data = json.loads(request.body)
        brain_dump = data.get("brain_dump", "").strip()
    except:
        brain_dump = request.POST.get("brain_dump", "").strip()

    if not brain_dump:
        return JsonResponse({"error": "Missing brain_dump"}, status=400)
        
    user_id = str(request.user.pk)
    from core.services import triage_service
    result = triage_service.run_triage(user_id, brain_dump)
    
    if result.get("error"):
        return JsonResponse({"error": result["error"]}, status=500)
        
    return JsonResponse({
        "session_id": result["session_id"],
        "message": "Brain dump processed successfully"
    })


@login_required
def api_triage_suggestions(request, session_id):
    """
    Fetch all suggestions for a given session.
    """
    auth_error = api_auth_check(request)
    if auth_error: return auth_error

    user_id = str(request.user.pk)
    session = graphrag_service.get_triage_session(user_id, session_id)
    if not session:
        return JsonResponse({"error": "Session not found"}, status=404)
        
    suggestions = graphrag_service.get_suggestions_for_session(user_id, session_id)
    pending_suggestions = [s for s in suggestions if s.accepted_bool is None]
    
    import json
    parsed = []
    for s in pending_suggestions:
        try:
            payload = json.loads(s.payload_json)
            parsed.append({
                "id": s.id,
                **payload
            })
        except:
            pass
            
    return JsonResponse({
        "session": {
            "id": session.id,
            "input_text": session.input_text,
            "created_at": session.created_at.isoformat(),
        },
        "suggestions": parsed
    })


@csrf_exempt
def api_triage_apply(request):
    """
    Apply decisions (accept/reject/edit) to suggestions.
    """
    auth_error = api_auth_check(request)
    if auth_error: return auth_error

    if request.method != "POST":
        return JsonResponse({"error": "POST required"}, status=405)
        
    import json
    try:
        data = json.loads(request.body)
        session_id = data.get("session_id")
        decisions = data.get("decisions", [])
    except:
        return JsonResponse({"error": "Invalid JSON"}, status=400)
        
    if not session_id or not decisions:
        return JsonResponse({"error": "Missing session_id or decisions"}, status=400)
        
    user_id = str(request.user.pk)
    from core.services import triage_service
    try:
        triage_service.apply_suggestions(user_id, session_id, decisions)
        return JsonResponse({"success": True})
    except Exception as e:
        logger.exception("Failed to apply suggestions")
        return JsonResponse({"error": str(e)}, status=500)


def api_tasks(request):
    """
    Return all user tasks, enriched with projects and areas for filtering.
    """
    auth_error = api_auth_check(request)
    if auth_error: return auth_error

    user_id = str(request.user.pk)
    try:
        tasks_data = graphrag_service.list_tasks_with_context(user_id)
        projects = graphrag_service.list_projects(user_id)
        areas = graphrag_service.list_areas(user_id)
        
        data = []
        for t_dict in tasks_data:
            t = t_dict["task"]
            data.append({
                "id": t.id,
                "title": t.title,
                "status": t.status,
                "priority": t.priority,
                "urgency": t.urgency,
                "effort": t.effort,
                "description": t.description,
                "next_action": t.next_action,
                "project_id": t_dict["project_id"],
                "project_name": t_dict["project_name"],
                "area_id": t_dict["area_id"],
                "area_name": t_dict["area_name"],
            })
            
        projects_data = [{"id": p.id, "name": p.name.get("name", str(p.name)) if isinstance(p.name, dict) else p.name} for p in projects]
        areas_data = [{"id": a.id, "name": a.name.get("name", str(a.name)) if isinstance(a.name, dict) else a.name} for a in areas]
            
        return JsonResponse({
            "tasks": data,
            "projects": projects_data,
            "areas": areas_data
        })
    except Exception as e:
        logger.exception("Failed to fetch tasks")
        return JsonResponse({"error": str(e)}, status=500)


@login_required
def api_projects(request):
    """
    List all user projects with their status and task counts.
    """
    auth_error = api_auth_check(request)
    if auth_error: return auth_error

    user_id = str(request.user.pk)
    try:
        projects_data = graphrag_service.list_projects_with_stats(user_id)
        data = []
        for p_dict in projects_data:
            p = p_dict["project"]
            
            p_name = p.name.get("name", str(p.name)) if isinstance(p.name, dict) else p.name
            p_outcome = p.outcome.get("outcome", str(p.outcome)) if isinstance(p.outcome, dict) else p.outcome
            
            data.append({
                "id": p.id,
                "name": p_name,
                "outcome": p_outcome,
                "status": p.status,
                "task_count": p_dict["task_count"]
            })
        return JsonResponse({"projects": data})
    except Exception as e:
        logger.exception("Failed to fetch projects")
        return JsonResponse({"error": str(e)}, status=500)


@login_required
def api_project_detail(request, project_id):
    """
    Get project details, including all linked tasks.
    """
    auth_error = api_auth_check(request)
    if auth_error: return auth_error

    user_id = str(request.user.pk)
    try:
        result = graphrag_service.get_project_with_tasks(user_id, project_id)
        if not result:
            return JsonResponse({"error": "Project not found"}, status=404)
            
        p = result["project"]
        tasks = result["tasks"]
        
        p_name = p.name.get("name", str(p.name)) if isinstance(p.name, dict) else p.name
        p_outcome = p.outcome.get("outcome", str(p.outcome)) if isinstance(p.outcome, dict) else p.outcome
        
        project_data = {
            "id": p.id,
            "name": p_name,
            "outcome": p_outcome,
            "status": p.status,
            "tasks": [{
                "id": t.id,
                "title": t.title,
                "status": t.status,
                "priority": t.priority,
                "urgency": t.urgency,
                "effort": t.effort,
                "description": t.description,
                "next_action": t.next_action,
            } for t in tasks]
        }
        return JsonResponse({"project": project_data})
    except Exception as e:
        logger.exception("Failed to fetch project detail")
        return JsonResponse({"error": str(e)}, status=500)


@csrf_exempt
def api_task_status(request, task_id):
    """
    Update task status inline.
    """
    auth_error = api_auth_check(request)
    if auth_error: return auth_error

    if request.method != "PATCH":
        return JsonResponse({"error": "PATCH required"}, status=405)
        
    import json
    try:
        data = json.loads(request.body)
        status = data.get("status")
        if not status:
            return JsonResponse({"error": "status is required"}, status=400)
    except:
        return JsonResponse({"error": "Invalid JSON"}, status=400)
        
    user_id = str(request.user.pk)
    try:
        success = graphrag_service.update_task(user_id, task_id, {"status": status})
        if not success:
            return JsonResponse({"error": "Task not found"}, status=404)
        return JsonResponse({"success": True, "status": status})
    except Exception as e:
        logger.exception("Failed to update task")
        return JsonResponse({"error": str(e)}, status=500)
